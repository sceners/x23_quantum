/*************************************************************************************************
   qb_matrix.cpp
  
   - Matrix manipulation functions
                                                                                 2002/10/10 12:39
/************************************************************************************************/
#include "stdafx.h"

//________________________________________________________________________________________________

QB_MATRIX                               QB_MATRIX_IDENTITY =
{
    1.f, 0.f, 0.f, 0.f,
    0.f, 1.f, 0.f, 0.f,
    0.f, 0.f, 1.f, 0.f,
    0.f, 0.f, 0.f, 1.f
};

//________________________________________________________________________________________________

QB_MATRIX                               QB_MATRIX::operator * ( const QB_MATRIX &m2 ) const
{
    //------------------------------

    QB_MATRIX m1;
    int i;
    for ( i = 0; i<4; i++ )
    {
        int j;
        for ( j = 0; j<4; j++ )
        {
            int k;
            for ( k = 0, m1[i][j] = 0.f; k<4; k++ )
            {
                m1[i][j] += m[i][k]*m2[k][j];
            }
        }
    }

    return m1;

    //------------------------------
}

//________________________________________________________________________________________________

QB_MATRIX&                              QB_MATRIX::operator *= ( const QB_MATRIX& M )
{
    //------------------------------

    QB_MATRIX N;

    N.m[0][0] = m[0][0]*M.m[0][0] + m[0][1]*M.m[1][0] + m[0][2]*M.m[2][0];
    N.m[1][0] = m[1][0]*M.m[0][0] + m[1][1]*M.m[1][0] + m[1][2]*M.m[2][0];
    N.m[2][0] = m[2][0]*M.m[0][0] + m[2][1]*M.m[1][0] + m[2][2]*M.m[2][0];
    N.m[3][0] = m[3][0]*M.m[0][0] + m[3][1]*M.m[1][0] + m[3][2]*M.m[2][0] + M.m[3][0];

    N.m[0][1] = m[0][0]*M.m[0][1] + m[0][1]*M.m[1][1] + m[0][2]*M.m[2][1];
    N.m[1][1] = m[1][0]*M.m[0][1] + m[1][1]*M.m[1][1] + m[1][2]*M.m[2][1];
    N.m[2][1] = m[2][0]*M.m[0][1] + m[2][1]*M.m[1][1] + m[2][2]*M.m[2][1];
    N.m[3][1] = m[3][0]*M.m[0][1] + m[3][1]*M.m[1][1] + m[3][2]*M.m[2][1] + M.m[3][1];

    N.m[0][2] = m[0][0]*M.m[0][2] + m[0][1]*M.m[1][2] + m[0][2]*M.m[2][2];
    N.m[1][2] = m[1][0]*M.m[0][2] + m[1][1]*M.m[1][2] + m[1][2]*M.m[2][2];
    N.m[2][2] = m[2][0]*M.m[0][2] + m[2][1]*M.m[1][2] + m[2][2]*M.m[2][2];
    N.m[3][2] = m[3][0]*M.m[0][2] + m[3][1]*M.m[1][2] + m[3][2]*M.m[2][2] + M.m[3][2];

    //------------------------------

    this->i() = N.i();
    this->j() = N.j();
    this->k() = N.k();
    this->O() = N.O();

    return *this;

    //------------------------------
}

//________________________________________________________________________________________________

void                                    QB_MATRIX::Clear()
{
    //------------------------------

    float* dst = ( float* )&m;
    int msize = sizeof( QB_MATRIX )/4;
    _asm
    {
        mov     edi, dst;
        mov     ecx, msize;
        xor     eax, eax;
        rep     stosd;
    }

    //------------------------------
}

//________________________________________________________________________________________________

void                                    QB_MATRIX::Identity()
{
    //------------------------------

    float* dst = ( float* )&m;
    float* src = ( float* )&QB_MATRIX_IDENTITY;
    int msize = sizeof( QB_MATRIX )/4;
    _asm
    {
        mov     esi, src;
        mov     edi, dst;
        mov     ecx, msize;
        rep     movsd;
    }

    //------------------------------
}

//________________________________________________________________________________________________

void                                    QB_MATRIX::Inverse( )
{
    //------------------------------

    QB_MATRIX t = *this;

    int i;
    for ( i = 0; i<3; i++ )
    {
        for ( int j = 0; j<3; j++ )
        {
            m[i][j] = t[j][i];
        }
    }
    for ( i = 0; i<3; i++ )
    {
        m[3][i] = - t[3][0]*m[0][i] - t[3][1]*m[1][i] - t[3][2]*m[2][i];
    }

    //------------------------------
}

//________________________________________________________________________________________________

void                                QB_MATRIX::Pre_Rotate_X( const float angle )
{
    //------------------------------

    float ca, sa;

    ca = cosf( angle );
    sa = sinf( angle );

    //------------------------------

    QB_VECTOR J, K;
    J.x = ca*m[1][0] + sa*m[2][0];
    J.y = ca*m[1][1] + sa*m[2][1];
    J.z = ca*m[1][2] + sa*m[2][2];

    K.x = -sa*m[1][0] + ca*m[2][0];
    K.y = -sa*m[1][1] + ca*m[2][1];
    K.z = -sa*m[1][2] + ca*m[2][2];

    j() = J;
    k() = K;

    //------------------------------
}

//________________________________________________________________________________________________

void                                QB_MATRIX::Pre_Rotate_Y( const float angle )
{
    //------------------------------

    float ca, sa;

    ca = cosf( angle );
    sa = sinf( angle );

    //------------------------------

    QB_VECTOR I, K;
    I.x = ca*m[0][0] - sa*m[2][0];
    I.y = ca*m[0][1] - sa*m[2][1];
    I.z = ca*m[0][2] - sa*m[2][2];

    K.x = sa*m[0][0] + ca*m[2][0];
    K.y = sa*m[0][1] + ca*m[2][1];
    K.z = sa*m[0][2] + ca*m[2][2];

    i() = I;
    k() = K;

    //------------------------------
}

//________________________________________________________________________________________________

void                                QB_MATRIX::Pre_Rotate_Z( const float angle )
{
    //------------------------------

    float ca, sa;

    ca = cosf( angle );
    sa = sinf( angle );

    //------------------------------

    QB_VECTOR I, J;
    I.x = ca*m[0][0] + sa*m[1][0];
    I.y = ca*m[0][1] + sa*m[1][1];
    I.z = ca*m[0][2] + sa*m[1][2];

    J.x = -sa*m[0][0] + ca*m[1][0];
    J.y = -sa*m[0][1] + ca*m[1][1];
    J.z = -sa*m[0][2] + ca*m[1][2];

    i() = I;
    j() = J;

    //------------------------------
}

//________________________________________________________________________________________________

void                                    QB_MATRIX::Rotation_XYZ( float ax,
                                            float ay,
                                            float az )
{
    //------------------------------

    float cx, sx;
    float cy, sy;
    float cz, sz;

    cx = cosf( ax );
    sx = sinf( ax );
    cy = cosf( ay );
    sy = sinf( ay );
    cz = cosf( az );
    sz = sinf( az );

    //------------------------------

    m[0][0] = cy*cz;
    m[0][1] = cy*sz;
    m[0][2] = -sy;

    m[1][0] = sx*sy*cz - cx*sz;
    m[1][1] = sx*sy*sz + cx*cz;
    m[1][2] = sx*cy;

    m[2][0] = cx*sy*cz + sx*sz;
    m[2][1] = cx*sy*sz - sx*cz;
    m[2][2] = cx*cy;

    //------------------------------
}

//________________________________________________________________________________________________

void                                    QB_MATRIX::Set_Rotation_YPR( float yaw,
                                            float pitch,
                                            float roll )
{
    //------------------------------

    Identity();
    Pre_Rotate_Z( yaw );
    Pre_Rotate_X( pitch );
    Pre_Rotate_Z( roll );

    //------------------------------
}

//________________________________________________________________________________________________

void                                    QB_MATRIX::Set_Rotation( const QB_QUAT& q )
{
    //------------------------

    float s;
    float xs, ys, zs;
    float wx, wy, wz;
    float xx, xy, xz;
    float yy, yz;
    float zz;

    //------------------------

    s = ( q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w );
    if ( s==0 )
        Identity();
    else
    {
        s = 2.f/s;    // if unitary quaternion, s=2
                      // U is the axis unitary vector, a the angle
        xs = q.x*s;   // xs=2*sin(a/2)*Ux
        ys = q.y*s;   // ys=2*sin(a/2)*Uy
        zs = q.z*s;   // zs=2*sin(a/2)*Uz

        wx = -q.w*xs; // wx=-cos(a/2)*2*sin(a/2)*Ux
        wy = -q.w*ys; // wy=-cos(a/2)*2*sin(a/2)*Uy
        wz = -q.w*zs; // wz=-cos(a/2)*2*sin(a/2)*Uz

        xx = q.x*xs;  // xx=2*sin(a/2)^2*Ux*Ux
        xy = q.x*ys;  // xy=2*sin(a/2)^2*Ux*Uy
        xz = q.x*zs;  // xz=2*sin(a/2)^2*Ux*Uz

        zz = q.z*zs;  // zz=2*sin(a/2)^2*Uz*Uz

        yy = q.y*ys;  // yy=2*sin(a/2)^2*Uy*Uy
        yz = q.y*zs;  // yz=2*sin(a/2)^2*Uy*Uz

        m[0][0] = 1.f - ( yy + zz); m[0][1] = xy - wz;           m[0][2] = xz + wy;
        m[1][0] = xy + wz;          m[1][1] = 1.f - ( xx + zz ); m[1][2] = yz - wx;
        m[2][0] = xz - wy;          m[2][1] = yz + wx;           m[2][2] = 1.f - ( xx + yy );
//        m[3][0] = 0.f;              m[3][1] = 0.f;               m[3][2] = 0.f;
    }

    //------------------------
}

//________________________________________________________________________________________________
